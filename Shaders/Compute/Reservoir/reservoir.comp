#include "../Random/random.comp"

struct Reservoir
{
    vec4 item;

    vec4 point_v_itemWeight;
    vec4 point_s_totalWeight;

    vec4 normal_v_numItems;
    vec4 normal_s_depth;

    float correction;
};

Reservoir CreateReservoir()
{
    Reservoir reservoir;
    reservoir.point_s_totalWeight.w = 0.0;
    reservoir.normal_v_numItems.w = 0;
    return reservoir;
}

void UpdateReservoirCorrection(inout Reservoir reservoir)
{
    reservoir.correction = reservoir.point_s_totalWeight.w / (reservoir.point_v_itemWeight.w * reservoir.normal_v_numItems.w);
}

void AddToReservoir(inout Reservoir reservoir, vec4 item, float itemWeight, Impact impact, inout uint state)
{
    reservoir.point_s_totalWeight.w += itemWeight;
    reservoir.normal_v_numItems.w++;

    float ratio = itemWeight / max(reservoir.point_s_totalWeight.w, EPS);
    if (reservoir.normal_v_numItems.w == 1 || RandomValue(state) <= ratio)
    {
        reservoir.item = item;
        reservoir.point_v_itemWeight.w = itemWeight;
        reservoir.point_s_totalWeight.xyz = impact.point;
        reservoir.normal_s_depth.xyz = impact.normal;
    }
}

void MergeReservoirs(inout Reservoir source, Reservoir target, inout uint state)
{
    float totalWeight = source.point_s_totalWeight.w + target.point_s_totalWeight.w;
    float ratio = target.point_s_totalWeight.w / totalWeight;

    if (source.normal_v_numItems.w == 0 || RandomValue(state) <= ratio)
    {
        source.item = target.item;
        source.point_v_itemWeight.w = target.point_v_itemWeight.w;
        source.point_s_totalWeight.xyz = target.point_s_totalWeight.xyz;
        source.normal_s_depth.xyz = target.normal_s_depth.xyz;
    }

    source.point_s_totalWeight.w = totalWeight;
    source.normal_v_numItems.w += target.normal_v_numItems.w;
}

void MergeReservoirs(inout Reservoir source, Reservoir target, float weight, inout uint state)
{
    Impact impact = CreateImpact(target.point_s_totalWeight.xyz, target.normal_s_depth.xyz);
    float mergeWeight = target.correction * target.normal_v_numItems.w * weight;

    source.normal_v_numItems.w += target.normal_v_numItems.w - 1;
    AddToReservoir(source, target.item, mergeWeight, impact, state);
}

vec4 GetReservoirValue(Reservoir reservoir)
{
    return reservoir.item * reservoir.correction;
}

float ComputeJacobian(Reservoir current, Reservoir sampled)
{
    vec3 ray_r = current.point_v_itemWeight.xyz - sampled.point_s_totalWeight.xyz;
    vec3 ray_q = sampled.point_v_itemWeight.xyz - sampled.point_s_totalWeight.xyz;

    float theta_r = dot(normalize(ray_r), sampled.normal_s_depth.xyz);
    float theta_q = dot(normalize(ray_q), sampled.normal_s_depth.xyz);

    return (theta_r / theta_q) * (dot(ray_q, ray_q) / dot(ray_r, ray_r));
}