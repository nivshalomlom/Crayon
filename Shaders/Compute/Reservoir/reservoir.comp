#include "../Random/random.comp"

struct ReservoirHitInfo
{
    vec4 normalDepth;
    vec4 impactPoint;
    vec4 samplePoint;
};

struct Reservoir
{
    vec4 item;

    float itemWeight;
    float totalWeight;

    uint numItems;
    uint state;
};

Reservoir CreateReservoir(uint state)
{
    Reservoir reservoir;
    reservoir.totalWeight = 0.0;
    reservoir.numItems = 0;
    reservoir.state = state;
    return reservoir;
}

float ReservoirCorrection(Reservoir reservoir)
{
    return reservoir.totalWeight / (reservoir.numItems * reservoir.itemWeight);
}

vec4 GetReservoirValue(Reservoir reservoir)
{
    return reservoir.item * ReservoirCorrection(reservoir);
}

bool AddToReservoir(inout Reservoir reservoir, vec4 item, float itemWeight, inout uint state, uint numItemsLimit = 0, uint seedState = 0)
{
    reservoir.totalWeight += itemWeight;
    reservoir.numItems++;

    bool accepted = RandomValue(state) <= itemWeight / max(reservoir.totalWeight, EPS);
    if (reservoir.numItems == 1 || accepted)
    {
        if (numItemsLimit > 0 && reservoir.numItems >= numItemsLimit)
        {
            reservoir.numItems = min(reservoir.numItems, numItemsLimit);
            reservoir.totalWeight -= reservoir.itemWeight;
        }

        if (seedState > 0)
            reservoir.state = seedState;

        reservoir.item = item;
        reservoir.itemWeight = itemWeight;
    }

    return accepted;
}

void MergeReservoirs(inout Reservoir source, Reservoir target, float weight, inout uint state)
{
    uint numItems = source.numItems + target.numItems;
    bool accepted = AddToReservoir(
        source, 
        target.item, 
        weight * target.numItems * ReservoirCorrection(target), 
        state
    );

    if (accepted)
        source.state = target.state;

    source.numItems = numItems;
}