#include "../Random/random.comp"

struct Reservoir
{
    vec4 item;
    vec4 normalDepth;

    float itemWeight;
    float totalWeight;

    uint numItems;
    uint state;
};

Reservoir CreateReservoir(uint state)
{
    Reservoir reservoir;
    reservoir.totalWeight = 0.0;
    reservoir.numItems = 0;
    reservoir.state = state;
    return reservoir;
}

float ReservoirCorrection(Reservoir reservoir)
{
    return reservoir.totalWeight / (reservoir.numItems * reservoir.itemWeight);
}

vec4 GetReservoirValue(Reservoir reservoir)
{
    return reservoir.item * ReservoirCorrection(reservoir);
}

bool AddToReservoir(inout Reservoir reservoir, vec4 item, float itemWeight, inout uint state)
{
    reservoir.totalWeight += itemWeight;
    reservoir.numItems++;

    float ratio = itemWeight / max(reservoir.totalWeight, EPS);
    if (reservoir.numItems == 1 || RandomValue(state) <= ratio)
    {
        reservoir.item = item;
        reservoir.itemWeight = itemWeight;

        return true;
    }

    return false;
}

void MergeReservoirs(inout Reservoir source, Reservoir target, inout uint state)
{
    float totalWeight = source.totalWeight + target.totalWeight;
    float ratio = target.totalWeight / totalWeight;

    if (source.numItems == 0 || RandomValue(state) <= ratio)
    {
        source.item = target.item;
        source.itemWeight = target.itemWeight;
        source.state = target.state;
    }

    source.totalWeight = totalWeight;
    source.numItems += target.numItems;
}

void MergeReservoirs(inout Reservoir source, Reservoir target, float weight, inout uint state)
{
    float mergeWeight = weight * target.numItems * ReservoirCorrection(target);
    if (mergeWeight <= 0)
        return;

    if (AddToReservoir(source, target.item, mergeWeight, state))
        source.state = target.state;

    source.numItems += target.numItems - 1;
}