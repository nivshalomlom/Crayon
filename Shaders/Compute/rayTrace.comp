#version 430 core

#include "./Rays/ray_intersections.comp"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32F, binding = 0) uniform image2D renderTarget;

// TODO: Move to buffered class
const vec3 skyColor = vec3(0.529, 0.808, 0.922);
const vec3 zenithColor = vec3(0.270, 0.470, 0.611);
const vec3 groundColor = vec3(0.3);

const vec3 sunlightDirection = vec3(-0.5, -1.0, 0.0);
const float sunItensity = 1;
const float sunFocus = 3;

const float antiAliasingIterations = 8.0;
const uint raysPerPixel = 10;
const uint rayBounces = 3;

vec3 EnvironmentLight(vec3 direction)
{
    float skyGradientT = pow(smoothstep(0.0, 0.4, direction.y), 0.35);
    vec3 skyGradient = mix(skyColor, zenithColor, skyGradientT);
    float sun = pow(max(0, dot(direction, -sunlightDirection)), sunFocus) * sunItensity;

    float groundToSkyT = smoothstep(-0.01, 0.0, direction.y);
    float sunMask = groundToSkyT >= 1.0 ? sun : 0.0;
    return mix(groundColor, skyGradient, groundToSkyT) + sunMask;
}

vec4 Trace(Ray ray, uint bounceLimit, inout uint state)
{
    vec3 incomingLight = vec3(0.0);
    vec3 rayColor = vec3(1.0);

    RayHit rayHit;
    for (uint i = 0; i <= bounceLimit; i++)
    {
        if (FireRay(ray, rayHit))
        {
            Material material = rayHit.material;

            vec4 emission = material.emissionColor * material.emissionStrength;
            ray = CreateReflection(rayHit, state);

            rayColor *= material.baseColor.xyz; 
            incomingLight += emission.xyz * rayColor;
        }
        else
        {
            incomingLight += EnvironmentLight(ray.direction) * rayColor;
            break;
        }
    }

    return vec4(incomingLight, 1.0);
}

void main()
{
    ivec2 dimensions = imageSize(renderTarget);
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

    if (coords.x >= dimensions.x || coords.y >= dimensions.y)
        return;

    uint state = coords.x + coords.y * dimensions.x;    
    vec4 color = vec4(0.0);

    RayHit hit;
    for (int i = 0; i < antiAliasingIterations; i++)
    {
        vec2 uv = vec2(coords + RandomVector2(state)) / dimensions;
        Ray ray = CreateCameraRayFromUV(uv);
        color += Trace(ray, rayBounces, state);
    }

    imageStore(renderTarget, coords, color / antiAliasingIterations);
}