#version 430 core

#include "./Rays/ray_intersections.comp"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform ivec2 dimensions;

vec3 Trace(Ray ray, uint bounceLimit, out Impact impact, inout uint state)
{
    vec3 incomingLight = vec3(0.0);
    vec3 rayColor = vec3(1.0);

    RayHit rayHit;
    if (!FireRay(ray, rayHit))
        return EnvironmentLight(ray.direction);

    impact = rayHit.impact;
    for (uint i = 0; i < bounceLimit; i++)
    {
        Material material = rayHit.material;
        vec3 normal = rayHit.impact.normal;
        vec3 emission = Emission(material);

        BRDFPoint point = CreateBRDFPoint(
            -ray.direction,
            normalize(rayHit.impact.normal + RandomDirection(state)),
            normal
        );

        ray.origin = rayHit.impact.point + normal * 0.0001;
        ray.direction = point.lightDirection;

        incomingLight += emission * rayColor;
        rayColor *= BRDF(point, material);

        if (Vec3Max(rayColor) <= EPS)
            break;

        if (!FireRay(ray, rayHit))
        {
            incomingLight += EnvironmentLight(ray.direction) * rayColor;
            break;
        }
    }

    return incomingLight;
}

void HandleRayMiss(inout Reservoir reservoir, Ray ray, inout uint state)
{
    vec4 incomingLight = vec4(EnvironmentLight(ray.direction), 1.0);
    float weight = dot(incomingLight, incomingLight);

    reservoir.normal_v_numItems.xyz = vec3(0);
    reservoir.normal_s_depth.w = -1;
    
    AddToReservoir(reservoir, incomingLight, weight, CreateImpact(vec3(0), vec3(0)), state);
}

void HandleRayHit(inout Reservoir reservoir, Ray ray, RayHit rayHit, inout uint state)
{
    Material material = rayHit.material;
    vec3 normal = rayHit.impact.normal;
    vec3 emission = Emission(material);

    BRDFPoint point = CreateBRDFPoint(-ray.direction, vec3(0), normal);
    Ray reflected = CreateRay(rayHit.impact.point, vec3(0));

    Impact impact;
    for (int i = 0; i < raysPerPixel; i++)
    {
        point.lightDirection = normalize(rayHit.impact.normal + RandomDirection(state));
        reflected.direction = point.lightDirection + normal * 0.0001;

        vec3 incomingLight = Trace(reflected, rayBounces, impact, state);
        vec3 outgoingLight = incomingLight * BRDF(point, material) + emission;
        AddToReservoir(reservoir, vec4(outgoingLight, 1.0), length(outgoingLight), impact, state);
    }

    UpdateReservoirCorrection(reservoir);
    reservoir.normal_v_numItems.xyz = normal;
    reservoir.point_v_itemWeight.xyz = rayHit.impact.point;
    reservoir.normal_s_depth.w = distance(ray.origin, rayHit.impact.point);
}

void main()
{
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

    if (coords.x >= dimensions.x || coords.y >= dimensions.y)
        return;

    uint kernal_ID = coords.x + coords.y * dimensions.x;
    uint state = kernal_ID + Camera.frameCounter * 6647369;
    Reservoir reservoir = CreateReservoir();

    vec2 uv = vec2(coords + RandomVector2(state)) / dimensions;
    Ray ray = CreateCameraRayFromUV(uv);

    RayHit rayHit;
    if (FireRay(ray, rayHit))
        HandleRayHit(reservoir, ray, rayHit, state);
    else
        HandleRayMiss(reservoir, ray, state);

    UpdateReservoirCorrection(reservoirs[kernal_ID]);
    MergeReservoirs(reservoirs[kernal_ID], reservoir, state);
}