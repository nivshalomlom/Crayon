#version 430 core

#include "./Rays/ray_trace.comp"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform ivec2 dimensions;

void HandleRayHit(uint kernal_ID, Ray ray, RayHit rayHit, inout uint state)
{
    Material material = rayHit.material;
    vec3 normal = rayHit.impact.normal;
    vec3 emission = Emission(material);

    BRDFPoint point = CreateBRDFPoint(-ray.direction, vec3(0), normal);
    Ray reflected = CreateRay(rayHit.impact.point, vec3(0));

    Impact impact;
    for (int i = 0; i < raysPerPixel; i++)
    {
        uint seedState = state;

        point.lightDirection = normalize(rayHit.impact.normal + RandomDirection(state));
        reflected.direction = point.lightDirection + normal * 0.0001;

        vec3 incomingLight = Trace(reflected, rayBounces, impact, state);
        vec3 outgoingLight = incomingLight * BRDF(point, material) + emission;

        float weight = length(outgoingLight) / RandomDirectionPDF(reflected.direction, normal);
        bool accepted = AddToReservoir(temporalReservoirs[kernal_ID], vec4(outgoingLight, 1.0), weight, seedState, state);

        if (accepted)
            reservoirsHitInfo[kernal_ID].samplePoint = vec4(impact.point, 1.0);
    }

    reservoirsHitInfo[kernal_ID].normalDepth = vec4(normal, distance(ray.origin, rayHit.impact.point));
}

void TemporalReuse(inout Reservoir reservoir, uint kernal_ID, Ray ray, RayHit rayHit, inout uint state)
{
    ivec2 prevCoords = ivec2(RayToPrevUV(ray) * dimensions);
    uint prev_ID = prevCoords.x + prevCoords.y * dimensions.x;

    if (prev_ID >= temporalReservoirs.length() || temporalReservoirs[prev_ID].numItems <= 0)
        return;

    uint prevState = temporalReservoirs[prev_ID].state;
    vec3 normal = rayHit.impact.normal;

    Ray reflected = CreateRay(
        rayHit.impact.point,
        normalize(normal + RandomDirection(prevState))
    );

    BRDFPoint point = CreateBRDFPoint(
        -ray.direction,
        reflected.direction,
        normal
    );

    Impact impact;
    vec3 incomingLight = Trace(reflected, rayBounces, impact, prevState);
    vec3 outgoingLight = incomingLight * BRDF(point, rayHit.material) + Emission(rayHit.material);

    float weight = length(outgoingLight) / RandomDirectionPDF(reflected.direction, normal);
    bool accepted = AddToReservoir(
        reservoir, 
        temporalReservoirs[prev_ID].item, 
        weight * ReservoirCorrection(temporalReservoirs[prev_ID]), 
        temporalReservoirs[prev_ID].state, 
        state
    );

    if (accepted)
        reservoirsHitInfo[kernal_ID].samplePoint = vec4(impact.point, 1.0);
}

void SampleLight(ivec2 coords, uint kernal_ID, inout uint state)
{
    vec2 uv = vec2(coords + RandomVector2(state)) / dimensions;
    Ray ray = CreateCameraRayFromUV(uv);

    RayHit rayHit;
    if (FireRay(ray, rayHit))
    {
        HandleRayHit(kernal_ID, ray, rayHit, state);
        reservoirsHitInfo[kernal_ID].impactPoint = vec4(rayHit.impact.point, 1.0);
    }
    else
    {
        vec4 incomingLight = vec4(EnvironmentLight(ray.direction), 1.0);
        float weight = dot(incomingLight, incomingLight);

        temporalReservoirs[kernal_ID] = CreateReservoir();
        reservoirsHitInfo[kernal_ID].normalDepth = vec4(0, 0, 0, -1);
        AddToReservoir(temporalReservoirs[kernal_ID], incomingLight, weight, -1, state);
    }

    temporalReservoirs[kernal_ID].numItems = min(temporalReservoirs[kernal_ID].numItems, 20);
}

void main()
{
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

    if (coords.x >= dimensions.x || coords.y >= dimensions.y)
        return;

    uint kernal_ID = coords.x + coords.y * dimensions.x;
    uint state = kernal_ID + Camera.frameCounter * 6647369;

    SampleLight(coords, kernal_ID, state);
}