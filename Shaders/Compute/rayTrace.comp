#version 430 core

#include "./Rays/ray_intersections.comp"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform ivec2 dimensions;

vec3 Trace(Ray ray, uint bounceLimit, inout uint state)
{
    vec3 incomingLight = vec3(0.0);
    vec3 rayColor = vec3(1.0);

    RayHit rayHit;
    for (uint i = 0; i <= bounceLimit; i++)
    {
        if (Vec3Max(rayColor) <= EPS)
            break;

        if (FireRay(ray, rayHit))
        {
            Material material = rayHit.material;
            vec3 normal = rayHit.impact.normal;
            vec3 emission = Emission(material);

            BRDFPoint point = CreateBRDFPoint(
                -ray.direction,
                normalize(rayHit.impact.normal + RandomDirection(state)),
                normal
            );

            ray.origin = rayHit.impact.point + normal * 0.0001;
            ray.direction = point.lightDirection;

            incomingLight += emission * rayColor;
            rayColor *= BRDF(point, material);
        }
        else
        {
            incomingLight += EnvironmentLight(ray.direction) * rayColor;
            break;
        }
    }

    return incomingLight;
}

void main()
{
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
    if (coords.x >= dimensions.x || coords.y >= dimensions.y)
        return;

    uint kernal_ID = coords.x + coords.y * dimensions.x;
    uint state = kernal_ID + Camera.frameCounter * 6647369;

    vec2 uv = vec2(coords + RandomVector2(state)) / dimensions;
    Ray cameraRay = CreateCameraRayFromUV(uv);

    RayHit rayHit;
    if (FireRay(cameraRay, rayHit))
    {
        Material material = rayHit.material;
        vec3 normal = rayHit.impact.normal;
        vec3 emission = Emission(material);

        BRDFPoint point = CreateBRDFPoint(-cameraRay.direction, vec3(0.0), normal);
        Ray ray = CreateRay(rayHit.impact.point, vec3(0.0));

        for (int i = 0; i < raysPerPixel; i++)
        {
            point.lightDirection = normalize(normal + RandomDirection(state));
            ray.direction = point.lightDirection + normal * 0.0001;

            vec3 incomingLight = Trace(ray, rayBounces, state);
            vec3 outgoingLight = emission + BRDF(point, material) * incomingLight;

            float weight = length(outgoingLight) / RandomDirectionPDF(ray.direction, normal);
            AddToReservoir(temporalReservoirs[kernal_ID], vec4(outgoingLight, 1.0), weight, state);
        }

        LoadIntoReservoirInfo(kernal_ID, normal, distance(rayHit.impact.point, Position(Camera.transform.worldToLocal)));
    }
    else
    {
        temporalReservoirs[kernal_ID] = CreateReservoir();
        LoadIntoReservoirInfo(kernal_ID, vec3(0), -1);

        vec3 outgoingLight = EnvironmentLight(cameraRay.direction);
        AddToReservoir(temporalReservoirs[kernal_ID], vec4(outgoingLight, 1.0), length(outgoingLight), state);
    }
}