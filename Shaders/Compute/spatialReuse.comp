#version 430 core

#include "./Rays/ray_intersections.comp"
#define MAX_SPATIAL_ITEMS 500

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform ivec2 dimensions;

bool IsObstructed(uint from_id, uint to_id)
{
    vec3 origin = reservoirsHitInfo[from_id].impactPoint.xyz;
    vec3 target = reservoirsHitInfo[from_id].samplePoint.xyz;

    Ray ray = CreateRay(
        origin,
        normalize(target - origin)
    );

    RayHit rayHit;
    return FireRay(ray, rayHit);
}

uint PickRandomNeighbor(ivec2 coords, ivec2 searchRadius, inout uint state)
{
    ivec2 neighbor = ivec2(
        RandomValue(max(coords.x - searchRadius.x, 0), min(coords.x + searchRadius.x, dimensions.x), state), 
        RandomValue(max(coords.y - searchRadius.y, 0), min(coords.y + searchRadius.y, dimensions.y), state)
    );

    return neighbor.x + neighbor.y * dimensions.x;
}

uint SpatialReuse(uint kernal_ID, ivec2 coords, ivec2 searchRadius, inout uint state)
{
    ReservoirHitInfo hitInfo = reservoirsHitInfo[kernal_ID];
    uint maxIterations = 3;

    if (spatialReservoirs[kernal_ID].numItems < MAX_SPATIAL_ITEMS / 2)
        maxIterations = 9;

    uint samplesAccepted = 0;
    for (int i = 0; i < maxIterations; i++)
    {
        uint neighbor_ID = PickRandomNeighbor(coords, searchRadius, state);
        float neighborDepth = reservoirsHitInfo[neighbor_ID].normalDepth.w;
        
        if (neighborDepth < 0 || abs(hitInfo.normalDepth.w - neighborDepth) > 0.05)
            continue;

        if (dot(hitInfo.normalDepth.xyz, reservoirsHitInfo[neighbor_ID].normalDepth.xyz) < 0.906)
            continue;

        float weight = temporalReservoirs[neighbor_ID].itemWeight;
        if (weight <= 0 || IsObstructed(kernal_ID, neighbor_ID))
            continue;

        samplesAccepted++;
        MergeReservoirs(spatialReservoirs[kernal_ID], temporalReservoirs[neighbor_ID], weight, state);
    }

    spatialReservoirs[kernal_ID].numItems = min(MAX_SPATIAL_ITEMS, spatialReservoirs[kernal_ID].numItems);

    return samplesAccepted;
}

void main()
{
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

    if (coords.x >= dimensions.x || coords.y >= dimensions.y)
        return;

    uint kernal_ID = coords.x + coords.y * dimensions.x;
    uint state = kernal_ID + Camera.frameCounter * 6647369;

    ReservoirHitInfo hitInfo = reservoirsHitInfo[kernal_ID];    
    if (hitInfo.normalDepth.w < 0)
        spatialReservoirs[kernal_ID] = temporalReservoirs[kernal_ID];
    
    ivec2 searchRadius = ivec2(dimensions * 0.1);
    while (SpatialReuse(kernal_ID, coords, searchRadius, state) == 0)
    {
        if (searchRadius.x < 3 || searchRadius.y < 3)
            break;

        searchRadius /= 2;
    }
}